//Servo
#include <Servo.h>

#include <VL53L1X.h>
#include "Adafruit_VL53L0X.h"
VL53L1X sensor1;
Adafruit_VL53L0X sensor2 = Adafruit_VL53L0X();
VL53L1X sensor3;

#include "Adafruit_TCS34725.h"
float red, green, blue;
uint16_t r, g, b, c;
int speed = 13;

#include "FastIMU.h"
#include <Wire.h>
#define IMU_ADDRESS 0x69     //Change to the address of the IMU
#define PERFORM_CALIBRATION  //Comment to disable startup calibration
BMI160 IMU;                  //Change to the name of any supported IMU!
calData calib = { 0 };       //Calibration data
AccelData IMUAccel;          //Sensor data
GyroData IMUGyro;
MagData IMUMag;
float angleZ = 0;
float angleX = 0;

//SETTINGS ACCELERATION AND SPEED
float currentSpeedL = 0;  //CM/S
float currentSpeedRear = 0;
float currentSpeedR = 0;  //CM/S

//Ball settings
bool hasBalls = false;
bool deliveredBalls = false;
bool outOfBallArea = false;
bool gotOut = false;
bool turnedRightLast = true;
int ballSize = 50;
int ballCounter = 0;
int totalBalls = 3;

Adafruit_TCS34725 colorSensorR = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_24MS, TCS34725_GAIN_4X);
Adafruit_TCS34725 colorSensorL = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_24MS, TCS34725_GAIN_4X);
Adafruit_TCS34725 colorSensorF = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_360MS, TCS34725_GAIN_4X);
Adafruit_TCS34725 colorSensorB = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_360MS, TCS34725_GAIN_4X);


//DEPTH SENSORS
bool useSensors = true;
bool gettingOut = false;
bool bypassMotorOptimization = false;
bool greenDelivered = false;

//SPECIFICATIONS CAR
#define wheelBaseWidth 10
#define wheelBaseLength 7
#define radiusWheelsF 3.12
#define radiusWheelsR 2.5  //2.4
#define pi 3.14

//Enviroment Settings
int whiteLimit = 200;
int maxBlack = 1023;
float intersectionWidth = 4.5;  //4,5
float lineWidth = 3;            //3

#include <Dynamixel2Arduino.h>
#define DXL_SERIAL Serial1
#define DEBUG_SERIAL Serial
const int DXL_DIR_PIN = 28;
const uint8_t MotorR_ID = 2;
const uint8_t MotorL_ID = 1;
const uint8_t MotorRear_ID = 3;
const float DXL_PROTOCOL_VERSION = 2.0;
Dynamixel2Arduino dxl(DXL_SERIAL, DXL_DIR_PIN);
using namespace ControlTableItem;


//*********************
//THESE SETTINGS ARE ONLY TO BE USED BY THE COMPUTER
#define pi 3.14

unsigned long int odoMillis = millis();

bool runMethod = true;
bool temp;  //Used to wait for methods
int values[8];
float width;
float position;
int distances[4];
float odoMeter = 0;
float prevPosition = 4;
float prevWidth = 0;
char colorR = 'W';
char colorL = 'W';
float standardWhiteValuesL = 0;
float standardWhiteValuesR = 0;


bool hasSeenLeft = false;
bool hasSeenRight = false;
bool hasSeenLeftInter = false;
bool hasSeenrightInter = false;
bool conductiveBottom = false;

Servo kloR;
Servo kloL;
Servo arm;
Servo backHitch;

void setup() {
  pinMode(18, OUTPUT);
  pinMode(19, INPUT);
  DEBUG_SERIAL.begin(115200);
  dxl.begin(1000000);
  dxl.setPortProtocolVersion(DXL_PROTOCOL_VERSION);

  dxl.ping(MotorL_ID);
  dxl.torqueOff(MotorL_ID);
  dxl.setOperatingMode(MotorL_ID, OP_VELOCITY);
  dxl.torqueOn(MotorL_ID);

  dxl.ping(MotorRear_ID);
  dxl.torqueOff(MotorRear_ID);
  dxl.setOperatingMode(MotorRear_ID, OP_VELOCITY);
  dxl.torqueOn(MotorRear_ID);

  dxl.ping(MotorR_ID);
  dxl.torqueOff(MotorR_ID);
  dxl.setOperatingMode(MotorR_ID, OP_VELOCITY);
  dxl.torqueOn(MotorR_ID);
  dxl.setGoalCurrent(MotorR_ID, 1023);

  TCA9548A(1);
  if (colorSensorR.begin()) {
    //Serial.println("Found sensor");
  } else {
    Serial.println("No TCS34725 1 found ... check your connections");
  }

  TCA9548A(0);
  if (colorSensorL.begin()) {
    //Serial.println("Found sensor");
  } else {
    Serial.println("No TCS34725 2 found ... check your connections");
  }

  TCA9548A(3);
  if (colorSensorF.begin()) {
    //Serial.println("Found sensor");
  } else {
    Serial.println("No TCS34725 3 found ... check your connections");
  }

  TCA9548A(2);
  if (colorSensorB.begin()) {
    //Serial.println("Found sensor");
  } else {
    Serial.println("No TCS34725 2 found ... check your connections");
  }

  TCA9548A(7);
  if (!sensor1.init()) {
    Serial.println(F("Failed to boot VL53L1X 1"));
  }
  sensor1.setDistanceMode(VL53L1X::Short);
  sensor1.setMeasurementTimingBudget(20);
  sensor1.setROISize(4, 4);

  TCA9548A(6);
  if (!sensor2.begin()) {
    Serial.println(F("Failed to boot VL53L0X"));
  }
  sensor2.startRangeContinuous();

  TCA9548A(5);
  if (!sensor3.init()) {
    Serial.println(F("Failed to boot VL53L1X 3"));
  }
  sensor3.setDistanceMode(VL53L1X::Short);
  sensor3.setMeasurementTimingBudget(20);
  sensor3.setROISize(4, 4);

  arm.attach(13);
  kloR.attach(12);
  kloL.attach(11);
  backHitch.attach(10);
  /*
  arm.write(10);
  kloR.write(120);
  kloL.write(60);
  */

  arm.write(145);
  kloR.write(170);
  kloL.write(10);

  backHitch.write(100);

  TCA9548A(3);
  colorSensorF.getRGB(&red, &green, &blue);
  colorSensorF.getRawData(&r, &g, &b, &c);

  Serial.print(red);
  Serial.print("    ");
  Serial.print(green);
  Serial.print("    ");
  Serial.print(blue);
  Serial.print("    ");
  Serial.println(c);



  standardWhiteValuesR = red;

  TCA9548A(0);
  colorSensorL.getRGB(&red, &green, &blue);

  standardWhiteValuesL = red;


  //IMU-----------------
  TCA9548A(4);
  Wire.begin();
  Wire.setClock(400000);  //400khz clock

  int err = IMU.init(calib, IMU_ADDRESS);
  if (err != 0) {
    Serial.print("Error initializing IMU: ");
    Serial.println(err);
    while (true) {
      ;
    }
  }

  if (err != 0) {
    Serial.print("Error Setting range: ");
    Serial.println(err);
    while (true) {
      ;
    }
  }

#ifdef PERFORM_CALIBRATION
  Serial.println("FastIMU Calibrated Quaternion example");
  Serial.println("Keep IMU level.");
  delay(100);
  IMU.calibrateAccelGyro(&calib);
  Serial.println("Calibration done!");
  Serial.println("Accel biases X/Y/Z: ");
  Serial.print(calib.accelBias[0]);
  Serial.print(", ");
  Serial.print(calib.accelBias[1]);
  Serial.print(", ");
  Serial.println(calib.accelBias[2]);
  Serial.println("Gyro biases X/Y/Z: ");
  Serial.print(calib.gyroBias[0]);
  Serial.print(", ");
  Serial.print(calib.gyroBias[1]);
  Serial.print(", ");
  Serial.println(calib.gyroBias[2]);

  IMU.init(calib, IMU_ADDRESS);
#endif
  //-----------------------------------------
}
unsigned long int lastMilli = millis();
unsigned long int resetMillisRight = millis();
unsigned long int resetMillisLeft = millis();

bool searchingBall = false;
bool hasBall = false;

void loop() {
  int start = millis();
  if (hasSeenrightInter || hasSeenLeftInter) {
    speed = 6;
    updateColors();
    Serial.println("Slowing down");
  } 
  else
    speed = 12;

  

  IMU.update();
  IMU.getAccel(&IMUAccel);
  IMU.getGyro(&IMUGyro);

  Serial.println(IMUAccel.accelY);
  angleZ = IMUAccel.accelY;

  if (angleZ > 0.15) {
    arm.write(135);
    if (speed != 6)
      speed = 14;
  } else if (angleZ < -0.1) {
    arm.write(145);
    speed = 6;
  } else {
    arm.write(145);
  }


  if (resetMillisRight + 1000 <= millis()) {
    resetMillisRight = millis();
    hasSeenrightInter = false;
    hasSeenRight = false;
  }

  if (resetMillisLeft + 1000 <= millis()) {
    resetMillisLeft = millis();
    hasSeenLeftInter = false;
    hasSeenLeft = false;
  }

  getArray();
  getWidthAndPos();
  getDistances();

  TCA9548A(1);
  colorSensorR.getRGB(&red, &green, &blue);
  colorSensorR.getRawData(&r, &g, &b, &c);

  if ((red > 120 && c > 350 && c < 500)) {
    stop();

    forwardDrive(20);

    delay(700);

    getArray();
    getWidthAndPos();

    if (width != 0) {
      forwardDrive(20);
      delay(1000);
      searchingBall = true;
    }
  }


  //searchingBall = true;

  if (searchingBall) {
    stop();
    arm.write(10);
    kloR.write(120);
    kloL.write(60);
    delay(2000);
    hasBalls = false;
    unsigned long int startSearchingBalls = millis();
    while (hasBalls == false) {
      for (int i = 0; i < 100; i++) {
        if (100000 < millis() - startSearchingBalls) {
          hasBalls = true;
          ballCounter = 999;
          break;
        }

        radiusDrive(0, 6, false);
        getDistances();
        if (distances[1] - distances[0] >= 50 && distances[0] != 0 && distances[1] != 0 && !isClose(distances[0], distances[2], 50) && distances[0] < 700) {
          if (distances[0] > 150) {
            pointTurn(-10);
            forwardDrive(15);
            delay(300);
          } else {
            pointTurn(-5);
            forwardDrive(6);
            delay(50);
          }
          stop();
          unsigned long int startTimmer = millis();
          while (distances[0] > 30 && distances[0] != 0 && (distances[1] - distances[0] >= 40 || distances[0] == 0 || distances[1] == 0) && !isClose(distances[0], distances[2], 150) && 15000 > millis() - startTimmer) {
            radiusDrive(50, speed, true);
            getDistances();
          }

          if (10000 < millis() - startTimmer) {
            radiusDrive(30, -6, true);
            delay(2000);
            pointTurn(100);
          }

          bypassMotorOptimization = true;
          if (distances[0] != 0 && distances[0] < 40 && !isClose(distances[0], distances[2], 100)) {
            stop();
            forwardDrive(-12);
            delay(700);
            stop();
            kloR.write(180);
            kloL.write(0);
            arm.write(175);
            delay(1200);
            radiusDrive(0, 6, true);
            delay(100);
            forwardDrive(9);
            delay(900);
            stop();
            kloR.write(105);
            kloL.write(75);

            delay(1000);

            TCA9548A(3);
            colorSensorF.getRGB(&red, &green, &blue);
            colorSensorF.getRawData(&r, &g, &b, &c);

            Serial.print(red);
            Serial.print("    ");
            Serial.print(green);
            Serial.print("    ");
            Serial.println(blue);

            if (isClose(red, 125, 14) && isClose(green, 95, 14) && isClose(blue, 64, 14)) {
              if (c > 2000) {
                Serial.println("Silver ball");
                //Silver
                ballCounter++;
                delay(1000);
                arm.write(10);
                delay(800);
                kloR.write(60);
                kloL.write(20);
                delay(600);
                kloR.write(145);
                kloL.write(25);
                delay(1000);
              } else {
                Serial.println("Black ball");
                //Black
                ballCounter++;
                delay(1000);
                arm.write(10);
                delay(800);
                kloR.write(160);
                kloL.write(120);
                delay(600);
                kloL.write(35);
                kloR.write(165);
                delay(1000);
              }
            } else {
              Serial.println("No ball");
              kloR.write(180);
              kloL.write(0);
              delay(600);

              resetODO();
              while (abs(odoMeter) < 100) {
                forwardDrive(-speed);
                updateDistanceDriven();
              }

              pointTurn(45);
            }

            arm.write(0);
            delay(500);
            kloR.write(120);
            kloL.write(60);
            getDistances();
          }
          bypassMotorOptimization = false;
          if (ballCounter >= totalBalls) {
            hasBalls = true;
            break;
            delay(100);
          }

          if (distances[0] != 0 && distances[0] < 40 && isClose(distances[0], distances[2], 100)) {
            stop();
            forwardDrive(-12);
            delay(700);
            stop();
            pointTurn(120);
          }
        }
      }

      //Closest wall
      getDistances();
      for (int i = 0; i < 50; i++) {
        getDistances();
        if (distances[0] < 300) {
          stop();
          break;
        }
      }

      for (int i = 0; i < 2; i++) {
        getDistances();
        while (distances[1] > 350) {
          forwardDrive(20);
          getDistances();
        }

        getDistances();
        getDistances();
        while (!isClose(distances[0], 300, 10)) {
          getDistances();
          if (distances[0] < 300)
            forwardDrive(-15);
          else
            forwardDrive(4);
        }

        centerOnWall();

        pointTurn(90);

        getDistances();
        resetODO();
        while (distances[2] > 200 && distances[0] > 200 && distances[1] > 300 && odoMeter < 200) {
          updateDistanceDriven();
          forwardDrive(20);
          getDistances();
        }

        getDistances();
        if (odoMeter > 150) {
          pointTurn(-90);

          getDistances();
          while (distances[2] > 300 && distances[0] > 300 && distances[1] > 300) {
            forwardDrive(20);
            getDistances();
          }
        }
      }
    }
    deliveredBalls = false;

    while (deliveredBalls == false) {
      unsigned long int timeout = millis();
      getDistances();
      while (distances[1] > 300) {
        forwardDrive(20);
        getDistances();

        if (distances[1] < 300 && (isClose(distances[0], distances[2], 100) && distances[1] - distances[0] >= 50)) {
          goto delivering;
        }
      }

      getDistances();

      while (!(isClose(distances[0], distances[2], 100) && distances[1] - distances[0] >= 50)) {
        centerOnWall();
        unsigned long int timeout = millis();
        if (distances[1] < 300 && (isClose(distances[0], distances[2], 100) && distances[1] - distances[0] >= 50)) {
          goto delivering;
        }

        getDistances();
        while (!isClose(distances[0], 250, 10) && 10000 > millis() - timeout) {
          getDistances();
          if (distances[0] < 250)
            forwardDrive(-15);
          else
            forwardDrive(4);

          if (distances[1] < 300 && (isClose(distances[0], distances[2], 100) && distances[1] - distances[0] >= 50)) {
            goto delivering;
          }
        }

        centerOnWall();

        if (distances[1] < 300 && (isClose(distances[0], distances[2], 100) && distances[1] - distances[0] >= 50)) {
          goto delivering;
        }

        pointTurn(90);

        stop();
        getDistances();
        resetODO();
        getDistances();
        while (distances[2] > 150 && distances[0] > 150 && distances[1] > 200 && odoMeter < 200) {
          updateDistanceDriven();
          forwardDrive(24);
          getDistances();
        }

        getDistances();

        if (odoMeter > 190) {
          pointTurn(-90);

          getDistances();
          while (distances[1] > 200 && distances[2] > 150 && distances[0]) {
            forwardDrive(20);
            getDistances();

            if (distances[1] < 300 && (isClose(distances[0], distances[2], 100) && distances[1] - distances[0] >= 50)) {
              goto delivering;
            }
          }
        }
      }
delivering:
      bypassMotorOptimization = true;
      speed = 10;
      resetODO();
      while (abs(odoMeter) < 200) {
        forwardDrive(-15);
        updateDistanceDriven();
      }

      pointTurn(-45);

      centerOnWall();

      bypassMotorOptimization = false;

      getDistances();
      while (!isClose(distances[0], 250, 30) && 15000 > millis() - timeout) {
        getDistances();
        if (distances[0] < 250)
          forwardDrive(-4);
        else
          forwardDrive(10);
      }

      bypassMotorOptimization = true;

      centerOnWall();

      pointTurn(90);

      bypassMotorOptimization = false;

      getDistances();
      getDistances();
      while (!isClose(distances[0], 150, 30) && 30000 > millis() - timeout) {
        getDistances();
        if (distances[0] < 150)
          forwardDrive(-4);
        else
          forwardDrive(15);
      }

      bypassMotorOptimization = true;

      pointTurn(-45);

      centerOnWall();

      getDistances();
      while (!isClose(distances[0], 150, 30) && 30000 > millis() - timeout) {
        getDistances();
        if (distances[0] < 150)
          forwardDrive(-4);
        else
          forwardDrive(10);
      }

      if ((isClose(distances[0], distances[2], 100) && distances[1] - distances[0] >= 50)) {
        stop();
        pointTurn(180);
        delay(100);
        forwardDrive(-6);
        delay(3000);
        stop();

        TCA9548A(2);
        colorSensorB.getRGB(&red, &green, &blue);

        Serial.print(red);
        Serial.print("    ");
        Serial.print(green);
        Serial.print("    ");
        Serial.println(blue);

        if (green > red && green > blue) {
          Serial.println("Dispensing silver balls");
          backHitch.write(145);
          delay(3000);
          backHitch.write(100);
          greenDelivered = true;
        } else if (red > 160 && greenDelivered) {
          Serial.println("Dispensing black balls");
          backHitch.write(55);
          delay(3000);
          backHitch.write(100);
          break;
        } else {
          Serial.println("Not a valid color");
        }

        resetODO();
        while (abs(odoMeter) < 100) {
          forwardDrive(15);
          updateDistanceDriven();
        }

        pointTurn(-45);

        resetODO();
        while (abs(odoMeter) < 200) {
          forwardDrive(15);
          updateDistanceDriven();
        }

        pointTurn(-90);

        bypassMotorOptimization = false;
      }
    }
    gotOut = false;
    while (gotOut == false) {
      gettingOut = true;
      getDistances();
      while (distances[1] > 200) {
        forwardDrive(20);
        getDistances();

        if (values[3] > whiteLimit && values[4] > whiteLimit) {
          gotOut = true;
          stop();
          break;
        }
      }

      getDistances();
      getDistances();
      while (!isClose(distances[1], 150, 10)) {
        getDistances();
        if (distances[1] < 150)
          forwardDrive(-4);
        else
          forwardDrive(4);

        if (values[3] > whiteLimit && values[4] > whiteLimit) {
          gotOut = true;
          stop();
          break;
        }
      }

      centerOnWall();

      stop();

      pointTurn(90);

      stop();
      getDistances();
      resetODO();
      getDistances();
      while (distances[2] > 150 && distances[0] > 150 && distances[1] > 200 && odoMeter < 200) {
        updateDistanceDriven();
        forwardDrive(20);
        getDistances();
        if (values[3] > whiteLimit && values[4] > whiteLimit) {
          gotOut = true;
          stop();
          break;
        }
      }

      getDistances();
      if (odoMeter > 150) {
        pointTurn(-70);

        getDistances();
        while (distances[1] > 200) {
          forwardDrive(20);
          getDistances();
          if (values[3] > whiteLimit && values[4] > whiteLimit) {
            gotOut = true;
            stop();
            break;
          }
        }
      }
    }
    arm.write(145);
    kloR.write(170);
    kloL.write(10);
    gettingOut = false;
    searchingBall = false;
  } else if ((hasSeenRight && colorR == 'B') || (hasSeenLeft && colorL == 'B')) {
    Serial.println("Turning");
    bypassMotorOptimization = true;
intersection:
    speed = 6;
    forwardDrive(speed);

    bool tempr = hasSeenRight;
    bool templ = hasSeenLeft;

    for (int i = 0; i < 1; i++) {
      updateColors();
    }

    if (tempr) {
      hasSeenRight = true;
      colorR = 'B';
    }

    if (templ) {
      hasSeenLeft = true;
      colorL = 'B';
    }

    if (hasSeenLeft && hasSeenRight && colorR == 'B' && colorL == 'B') {
      stop();

      pointTurn(-180);

      hasSeenLeft = false;
      hasSeenRight = false;
      colorL = 'W';
      colorR = 'W';
    } else {
      if (hasSeenLeft && colorL == 'B' && hasSeenRight != true) {
        stop();

        pointTurn(-90);
        hasSeenLeft = false;
        colorL = 'W';
      }

      if (hasSeenRight && colorR == 'B' && hasSeenLeft != true) {
        stop();

        pointTurn(90);
        hasSeenRight = false;
        colorR = 'W';
      }
    }
    vipeColors();
    bypassMotorOptimization = false;
  } else if (distances[1] <= 50 && distances[1] != 0) {
    bypassMotorOptimization = true;
    arm.write(10);
    delay(100);

    resetODO();
    while (abs(odoMeter) < 40) {
      forwardDrive(speed);
      updateDistanceDriven();
    }

    pointTurn(90);

    getDistances();

    if (distances[1] > 200) {
      getArray();

      while (values[4] - whiteLimit < 150) {
        radiusDrive(15, speed, true);
        getArray();
      }

      resetODO();
      while (abs(odoMeter) < 20) {
        forwardDrive(speed);
        updateDistanceDriven();
      }

      pointTurn(45);

      resetODO();
      while (abs(odoMeter) < 40) {
        forwardDrive(-speed);
        updateDistanceDriven();
      }
      vipeColors();

      getDistances();

      distances[1] = 0;
      bypassMotorOptimization = false;
      arm.write(145);
      delay(300);
    } else {
      pointTurn(-180);
      resetODO();
      resetODO();
      while (abs(odoMeter) < 20) {
        forwardDrive(speed);
        updateDistanceDriven();
      }

      getArray();

      while (values[4] - whiteLimit < 150) {
        radiusDrive(15, speed, false);
        getArray();
      }

      resetODO();
      while (abs(odoMeter) < 20) {
        forwardDrive(speed);
        updateDistanceDriven();
      }

      pointTurn(-45);

      resetODO();
      while (abs(odoMeter) < 40) {
        forwardDrive(-speed);
        updateDistanceDriven();
      }
      vipeColors();

      getDistances();

      distances[1] = 0;
      bypassMotorOptimization = false;
      arm.write(145);
      delay(300);
    }
  } else if (width <= lineWidth && width != 0) {
    if (position <= 2 && position != 0) {  // Change to adapt to previous line placement
      hasSeenLeftInter = true;
      resetMillisLeft = millis();
      hasSeenrightInter = false;
      speed = 6;
    }

    if (position >= 5) {
      if (!hasSeenrightInter) {
        vipeColors();
      }
      hasSeenrightInter = true;
      resetMillisRight = millis();
      hasSeenLeftInter = false;
      speed = 6;
    }

    bool temp = false;
    if (position < 3.5)
      temp = true;
    radiusDrive(50 * pow(0.15, abs(position - 3.5)) + 5, speed, temp);
    //radiusDrive(100 - (7 * pow(abs(position - 3.5), 2)), speed, temp);
    //radiusDrive(100 * pow(0.1, abs(position - 3.5)), speed, temp);
  } else if (width > lineWidth) {
    forwardDrive(speed);

    if (position < 3.5) {  // Change to adapt to previous line placement
      hasSeenLeftInter = true;
      resetMillisLeft = millis();
      hasSeenrightInter = false;
    }

    if (position >= 3.5) {
      if (!hasSeenrightInter) {
        vipeColors();
      }
      hasSeenrightInter = true;
      resetMillisRight = millis();
      hasSeenLeftInter = false;
    }
  } else if (width == 0) {

    if (red > 160) {
      stop();
      delay(7000);
    }

    speed = 8;
    if (hasSeenrightInter) {
      resetODO();

      while (odoMeter < 5) {
        if (red > 160) {
          stop();
          delay(7000);
        }
        forwardDrive(speed);
        updateDistanceDriven();
        updateColors();
        if ((colorR == 'B' && hasSeenRight) || (colorL == 'B' && hasSeenLeft)) {
          Serial.println("Shit 2");
          goto intersection;
        }
      }
      stop();

      getArray();
      getWidthAndPos();
      while ((position > 3.5 || width == 0) && (!hasSeenRight || colorR != 'B') && (!hasSeenLeft || colorL != 'B')) {
        radiusDrive(0, speed, false);
        getArray();
        getWidthAndPos();
      }
      stop();
    } else if (hasSeenLeftInter) {
      resetODO();

      while (odoMeter < 5) {
        if (red > 160) {
          stop();
          delay(7000);
        }
        forwardDrive(speed);
        updateDistanceDriven();
        updateColors();

        if ((colorR == 'B' && hasSeenRight) || (colorL == 'B' && hasSeenLeft)) {
          goto intersection;
        }
      }
      stop();

      getArray();
      getWidthAndPos();
      while (position < 3.5 && (!hasSeenRight || colorR != 'B') && (!hasSeenLeft || colorL != 'B') && !conductiveBottom) {
        radiusDrive(0, speed, true);
        getArray();
        getWidthAndPos();
      }
      stop();
    } else {
      forwardDrive(speed);
    }
    vipeColors();
  }
  int stop = millis();

  //Serial.print(stop - start);
  //Serial.println("ms");
}

char prevColorR = 'W';
char prevColorL = 'W';

bool doneRed = false;
unsigned long int colorRTimer = millis();
unsigned long int colorLTimer = millis();
float lastRed[20];
float lastGreen[20];
float lastBlue[20];

float lastRedLeft[20];
float lastGreenLeft[20];
float lastBlueLeft[20];

void updateColors() {
  TCA9548A(0);
  colorSensorL.getRGB(&red, &green, &blue);
  colorSensorL.getRawData(&r, &g, &b, &c);

  if (green > blue && green > red) {
    hasSeenLeft = true;
    colorL = 'G';
    resetMillisLeft = millis();
    Serial.println("Found left");
  } else if (c < 80) {
    colorL = 'B';
    Serial.println("Found black");
  } else
    colorL = 'W';

  TCA9548A(1);
  colorSensorR.getRGB(&red, &green, &blue);
  colorSensorR.getRawData(&r, &g, &b, &c);

  if (green > blue && green > red) {
    hasSeenRight = true;
    colorR = 'G';
    resetMillisRight = millis();
    Serial.println("Found right");
  } else if (c < 80) {
    colorR = 'B';
    Serial.println("Found black");
  } else
    colorR = 'W';
}

void vipeColors() {
  for (int i = 0; i < 19; i++) {
    lastRed[i] = 0;
    lastRedLeft[i] = 0;
  }
}

bool isClose(float x1, float x2, float tolerance) {
  if (abs(x1 - x2) < tolerance)
    return true;
  else
    return false;
}

void forwardDrive(int wantedSpeed) {
  currentSpeedL = wantedSpeed;
  currentSpeedR = wantedSpeed;
  currentSpeedRear = wantedSpeed;
  setSpeedMotors();
}

float prevCurrentSpeedR = 0;
float prevCurrentSpeedRear = 0;
float prevCurrentSpeedL = 0;

void setSpeedMotors() {
  if (searchingBall)
    checkDrivingOut();

  if (!isClose(currentSpeedR, prevCurrentSpeedR, 0.8)) {
    if (currentSpeedR < 0)
      dxl.setGoalVelocity(MotorR_ID, abs(currentSpeedR / (radiusWheelsF * 2 * pi)) * 9 * 60);
    else
      dxl.setGoalVelocity(MotorR_ID, 1024 + (currentSpeedR / (radiusWheelsF * 2 * pi)) * 9 * 60);
  }

  if (!isClose(currentSpeedL, prevCurrentSpeedL, 0.8)) {
    if (currentSpeedL < 0)
      dxl.setGoalVelocity(MotorL_ID, 1024 + abs((currentSpeedL / (radiusWheelsF * 2 * pi)) * 9 * 60));
    else
      dxl.setGoalVelocity(MotorL_ID, ((currentSpeedL / (radiusWheelsF * 2 * pi)) * 9 * 60));
  }

  if (!isClose(currentSpeedRear, prevCurrentSpeedRear, 0.8)) {
    if (currentSpeedRear < 0)
      dxl.setGoalVelocity(MotorRear_ID, 1024 + abs((currentSpeedRear / (radiusWheelsR * 2 * pi)) * 9 * 60));
    else
      dxl.setGoalVelocity(MotorRear_ID, ((currentSpeedRear / (radiusWheelsR * 2 * pi)) * 9 * 60));
  }

  if (bypassMotorOptimization) {
    if (!isClose(currentSpeedR, prevCurrentSpeedR, 0.8)) {
      if (currentSpeedR < 0)
        dxl.setGoalVelocity(MotorR_ID, abs(currentSpeedR / (radiusWheelsF * 2 * pi)) * 9 * 60);
      else
        dxl.setGoalVelocity(MotorR_ID, 1024 + (currentSpeedR / (radiusWheelsF * 2 * pi)) * 9 * 60);
    }

    if (!isClose(currentSpeedL, prevCurrentSpeedL, 0.8)) {
      if (currentSpeedL < 0)
        dxl.setGoalVelocity(MotorL_ID, 1024 + abs((currentSpeedL / (radiusWheelsF * 2 * pi)) * 9 * 60));
      else
        dxl.setGoalVelocity(MotorL_ID, ((currentSpeedL / (radiusWheelsF * 2 * pi)) * 9 * 60));
    }

    if (!isClose(currentSpeedRear, prevCurrentSpeedRear, 0.8)) {
      if (currentSpeedRear < 0)
        dxl.setGoalVelocity(MotorRear_ID, 1024 + abs((currentSpeedRear / (radiusWheelsR * 2 * pi)) * 9 * 60));
      else
        dxl.setGoalVelocity(MotorRear_ID, ((currentSpeedRear / (radiusWheelsR * 2 * pi)) * 9 * 60));
    }
  }

  prevCurrentSpeedR = currentSpeedR;
  prevCurrentSpeedRear = currentSpeedRear;
  prevCurrentSpeedL = currentSpeedL;
}

void getWidthAndPos() {
  float start = 0;
  float end = 0;

  for (int i = 0; i <= 7; i++) {
    if (values[i] - whiteLimit > 0) {
      start = i - (mapF(values[i], whiteLimit, maxBlack, 0, 1)) + 0.5;
      break;
    }
  }

  for (int i = 7; i >= 0; i--) {
    if (values[i] - whiteLimit > 0) {
      end = i + (mapF(values[i], whiteLimit, maxBlack, 0, 1)) - 0.5;
      break;
    }
  }

  if (width <= lineWidth - 1 && width != 0) {
    prevWidth = width;
    prevPosition = position;
  } else {
    prevWidth = 10;
  }

  width = end - start;
  position = (start + end) / 2;

  //Serial.println(position);
  //Serial.println(width);
}

float mapF(float x, float in_min, float in_max, float out_min, float out_max) {
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

float getK(int x1, int x2, int y1, int y2) {
  float deltaY = y2 - y1;
  float deltaX = x2 - x1;
  float k = deltaY / deltaX;

  return k;
}

void getDistances() {
  if (true) {
    VL53L0X_RangingMeasurementData_t measure;
    if (searchingBall) {
      TCA9548A(7);
      distances[0] = sensor1.readRangeSingleMillimeters();

      TCA9548A(5);
      distances[2] = sensor3.readRangeSingleMillimeters();
    }
    TCA9548A(6);
    sensor2.rangingTest(&measure, false);
    if (measure.RangeStatus != 4) {  // phase failures have incorrect data
      distances[1] = measure.RangeMilliMeter - 50;
    } else {
      distances[1] = 0;
    }
    /* Debugging
    Serial.println(distances[2]);
    Serial.println("---");
    Serial.println(distances[0]);
    Serial.println("---");
    Serial.println(distances[2] - distances[0]);
    */
  }
}

void getArray() {
  values[0] = analogRead(7);
  values[1] = analogRead(6);
  values[2] = analogRead(5);
  values[3] = analogRead(4);
  values[4] = analogRead(3);
  values[5] = analogRead(2);
  values[6] = analogRead(1);
  values[7] = analogRead(0);

  //Serial.println(width);





  /*Debugging
  Serial.print(values[0]);
  Serial.print("   ");
  Serial.print(values[1]);
  Serial.print("   ");
  Serial.print(values[2]);
  Serial.print("   ");
  Serial.print(values[3]);
  Serial.print("   ");
  Serial.print(values[4]);
  Serial.print("   ");
  Serial.print(values[5]);
  Serial.print("   ");
  Serial.print(values[6]);
  Serial.print("   ");
  Serial.println(values[7]);
  Serial.print("   ");
  */
}

void radiusDrive(float radius, int wantedSpeedOutside, bool reversed) {
  float degreesPerSecond;
  if (reversed) {
    float outerRadius = radius + (wheelBaseWidth / 2);
    currentSpeedR = wantedSpeedOutside;
    //currentSpeedR += mathSign(wantedSpeedOutside - currentSpeedR) * 2;
    degreesPerSecond = wantedSpeedOutside / (outerRadius * 2 * pi) * 360;
    float innerRadius = (radius - (wheelBaseWidth / 2));
    currentSpeedL = degreesPerSecond * ((innerRadius * 2 * pi) / 360);
  } else {
    float outerRadius = radius + (wheelBaseWidth / 2);
    currentSpeedL = wantedSpeedOutside;
    //currentSpeedL += mathSign(wantedSpeedOutside - currentSpeedL) * 2;
    degreesPerSecond = wantedSpeedOutside / (outerRadius * 2 * pi) * 360;
    float innerRadius = (radius - (wheelBaseWidth / 2));
    currentSpeedR = degreesPerSecond * ((innerRadius * 2 * pi) / 360);
  }

  float radiusRear = radius + (sqrtf((radius * radius) + (wheelBaseLength * wheelBaseLength)) - radius);
  float angleOfAttack = 90 - (atanf(radiusRear / wheelBaseLength));
  float speedTangent = degreesPerSecond * ((radiusRear * 2 * pi) / 360);
  currentSpeedRear = speedTangent * cosf(angleOfAttack);

  if (radius == 0) {
    currentSpeedRear = 0;
  }

  if (currentSpeedRear > 28) {
    radiusDrive(radius, wantedSpeedOutside - 1, reversed);
    return;
  }
  Serial.println(radius);
  setSpeedMotors();
}

void pointTurn(float degrees) {
  bool reversed = false;
  float degreesPerSecond = 0;
  float degreesDone = 0;
  unsigned long int millies = millis();

  if (degrees < 0)
    reversed = true;

  unsigned long int start = millis();
  unsigned long int startPointTurn = millis();
  float rotatedDegrees = 0;
  while (abs(rotatedDegrees) <= abs(degrees)) {
    if (millis() - startPointTurn > 3000) {
      resetODO();
      while (abs(odoMeter) < 30) {
        forwardDrive(15);
        updateDistanceDriven();
        startPointTurn = millis();
      }
    }
    IMU.update();
    IMU.getAccel(&IMUAccel);
    IMU.getGyro(&IMUGyro);
    rotatedDegrees += (millis() - start) * IMUGyro.gyroX / 1000;
    start = millis();
    Serial.print(rotatedDegrees);
    Serial.print("    ");
    Serial.println(IMUGyro.gyroX);
    radiusDrive(0, 12, reversed);
  }

  stop();
}

int mathSign(int x) {
  if (x > 0) return 1;
  if (x < 0) return -1;
  return 0;
}

void updateDistanceDriven() {
  odoMeter += ((millis() - odoMillis) * ((currentSpeedL + currentSpeedR) / 2)) / 100;
  odoMillis = millis();
}

void resetODO() {
  odoMeter = 0;
  odoMillis = millis();
}

void stop() {
  currentSpeedL = 0;
  currentSpeedR = 0;
  currentSpeedRear = 0;
  setSpeedMotors();
}

void TCA9548A(uint8_t bus) {
  Wire.beginTransmission(0x70);  // TCA9548A address is 0x70
  Wire.write(1 << bus);          // send byte to select bus
  Wire.endTransmission();
}

void checkDrivingOut() {
  getArray();

  if (((values[3] > whiteLimit && values[4] > whiteLimit) || conductiveBottom) && !gettingOut) {
    gettingOut = true;
    stop();
    resetODO();
    while (abs(odoMeter) < 100) {
      forwardDrive(-20);
      updateDistanceDriven();
    }
    pointTurn(90);
    resetODO();
    while (abs(odoMeter) < 200) {
      forwardDrive(10);
      updateDistanceDriven();
    }
    pointTurn(-70);
    gettingOut = false;
  }
}

void centerOnWall() {
  getDistances();
  unsigned long int time = millis();
  bool firstRight = true;
  if (distances[2] > distances[0]) {
    firstRight = true;
  } else {
    firstRight = false;
  }
  while (!isClose(distances[0], distances[2], 5)) {
    getDistances();
    if (distances[2] > distances[0]) {
      radiusDrive(0, 4, true);
      if (!firstRight || millis() - time > 2500)
        break;
    } else {
      radiusDrive(0, 4, false);
      if (firstRight || millis() - time > 2500)
        break;
    }
  }
}